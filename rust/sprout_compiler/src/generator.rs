// Enhanced WASM/Android Generator for SproutScript

use crate::ast::*;
use anyhow::{Context, Result};
use serde_json::json;

#[derive(Debug, Clone)]
pub struct GeneratorOptions {
    pub target: TargetPlatform,
    pub optimize: bool,
    pub include_debug_info: bool,
}

#[derive(Debug, Clone)]
pub enum TargetPlatform {
    Wasm,
    Android,
    Ios,
}

impl Default for GeneratorOptions {
    fn default() -> Self {
        GeneratorOptions {
            target: TargetPlatform::Wasm,
            optimize: true,
            include_debug_info: false,
        }
    }
}

pub struct CodeGenerator {
    options: GeneratorOptions,
}

impl CodeGenerator {
    pub fn new(options: GeneratorOptions) -> Self {
        CodeGenerator { options }
    }

    pub fn generate(&self, app: &App) -> Result<String> {
        match self.options.target {
            TargetPlatform::Wasm => self.generate_wasm(app),
            TargetPlatform::Android => self.generate_android(app),
            TargetPlatform::Ios => self.generate_ios(app),
        }
    }

    fn generate_wasm(&self, app: &App) -> Result<String> {
        let mut wasm_code = String::new();
        
        // Security: Generate safe WASM code
        wasm_code.push_str("(module\n");
        
        // Generate imports
        wasm_code.push_str("  (import &quot;env&quot; &quot;log&quot; (func $log (param i32 i32)))\n");
        wasm_code.push_str("  (import &quot;env&quot; &quot;get_state&quot; (func $get_state (param i32) (result i32)))\n");
        wasm_code.push_str("  (import &quot;env&quot; &quot;set_state&quot; (func $set_state (param i32 i32)))\n");
        
        // Generate memory
        wasm_code.push_str("  (memory (export &quot;memory&quot;) 1)\n");
        wasm_code.push_str("  (global $pointer (mut i32) (i32.const 0))\n");
        
        // Generate screen functions
        for (index, screen) in app.screens.iter().enumerate() {
            wasm_code.push_str(&format!(
                "  (func $screen_{} (export &quot;render_screen_{}&quot;)\n",
                index, index
            ));
            
            // Generate UI elements
            for (ui_index, ui_element) in screen.ui.iter().enumerate() {
                match ui_element {
                    UiElement::Label { text } => {
                        wasm_code.push_str(&format!("    ;; Label: {}\n", text));
                        // Security: Sanitize text for WASM
                        let sanitized = self.sanitize_for_wasm(text)?;
                        wasm_code.push_str(&format!("    (call $log (i32.const {}) (i32.const {}))\n", ui_index, sanitized.len()));
                    }
                    UiElement::Button { label, action } => {
                        wasm_code.push_str(&format!("    ;; Button: {}\n", label));
                        self.generate_action_code(&mut wasm_code, action, 2)?;
                    }
                    _ => {}
                }
            }
            
            wasm_code.push_str("  )\n");
        }
        
        // Generate screen table
        wasm_code.push_str("  (table $screen_table {} funcref)\n", app.screens.len());
        
        wasm_code.push_str(")\n");
        
        // Validate generated WASM
        self.validate_wasm(&wasm_code)?;
        
        Ok(wasm_code)
    }

    fn generate_android(&self, app: &App) -> Result<String> {
        let mut android_code = String::new();
        
        // Security: Generate safe Android/Kotlin code
        android_code.push_str("package com.sproutapp.sprout\n\n");
        android_code.push_str("import androidx.compose.runtime.*\n\n");
        android_code.push_str("// Generated by Sprout Compiler\n");
        android_code.push_str("// Security: This code is automatically validated\n\n");
        
        // Generate screen composables
        for screen in &app.screens {
            android_code.push_str(&format!(
                "@Composable\nfun {}Screen(state: MutableState<ScreenState>) {{\n",
                screen.name
            ));
            
            // Generate UI elements
            for ui_element in &screen.ui {
                match ui_element {
                    UiElement::Label { text } => {
                        let sanitized = self.sanitize_for_android(text)?;
                        android_code.push_str(&format!("    Text(text = &quot;{}&quot;)\n", sanitized));
                    }
                    UiElement::Button { label, action } => {
                        let sanitized = self.sanitize_for_android(label)?;
                        android_code.push_str(&format!("    Button(onClick = {{ /* TODO: {} */ }}) {{\n", action.to_string()));
                        android_code.push_str(&format!("        Text(&quot;{}&quot;)\n", sanitized));
                        android_code.push_str("    }\n");
                    }
                    _ => {}
                }
            }
            
            android_code.push_str("}\n\n");
        }
        
        Ok(android_code)
    }

    fn generate_ios(&self, app: &App) -> Result<String> {
        let mut ios_code = String::new();
        
        // Security: Generate safe iOS/Swift code
        ios_code.push_str("import SwiftUI\n\n");
        ios_code.push_str("// Generated by Sprout Compiler\n");
        ios_code.push_str("// Security: This code is automatically validated\n\n");
        
        // Generate screen views
        for screen in &app.screens {
            ios_code.push_str(&format!(
                "struct {}View: View {{\n",
                screen.name
            ));
            ios_code.push_str("    var body: some View {\n");
            
            // Generate UI elements
            for ui_element in &screen.ui {
                match ui_element {
                    UiElement::Label { text } => {
                        let sanitized = self.sanitize_for_ios(text)?;
                        ios_code.push_str(&format!("        Text(&quot;{}&quot;)\n", sanitized));
                    }
                    UiElement::Button { label, action } => {
                        let sanitized = self.sanitize_for_ios(label)?;
                        ios_code.push_str(&format!("        Button(action: {{ /* TODO: {} */ }}) {{\n", action.to_string()));
                        ios_code.push_str(&format!("            Text(&quot;{}&quot;)\n", sanitized));
                        ios_code.push_str("        }\n");
                    }
                    _ => {}
                }
            }
            
            ios_code.push_str("    }\n");
            ios_code.push_str("}\n\n");
        }
        
        Ok(ios_code)
    }

    fn generate_action_code(&self, code: &mut String, action: &Action, indent: usize) -> Result<()> {
        match action {
            Action::Navigation { target } => {
                code.push_str(&format!("{:indent$};; Navigate to {}\n", "", indent = indent * 4, target));
            }
            Action::UpdateState { variable, value } => {
                code.push_str(&format!("{:indent$};; Update state {} = {}\n", "", indent = indent * 4, variable, value));
            }
            Action::CallFunction { function, args } => {
                // Security: Validate function call
                if function.contains("eval") || function.contains("exec") {
                    return Err(anyhow::anyhow!("Dangerous function call detected"));
                }
                code.push_str(&format!("{:indent$};; Call {}({})\n", "", indent = indent * 4, function, args.join(", ")));
            }
            Action::If { condition, then, else: else_action } => {
                code.push_str(&format!("{:indent$};; If {}\n", "", indent = indent * 4, condition));
                self.generate_action_code(code, then, indent + 1)?;
                if let Some(else_act) = else_action {
                    code.push_str(&format!("{:indent$};; Else\n", "", indent = indent * 4));
                    self.generate_action_code(code, else_act, indent + 1)?;
                }
            }
            Action::Loop { variable, range, body } => {
                code.push_str(&format!("{:indent$};; For {} in {}\n", "", indent = indent * 4, variable, range));
                // Security: Limit loop iterations
                if body.len() > 100 {
                    return Err(anyhow::anyhow!("Loop body too large"));
                }
                for action in body {
                    self.generate_action_code(code, action, indent + 1)?;
                }
            }
        }
        
        Ok(())
    }

    fn sanitize_for_wasm(&self, text: &str) -> Result<String> {
        // Security: Sanitize text for WASM
        let sanitized = text
            .replace("\&quot;, "\\\&quot;)
            .replace("&quot;", "\\&quot;")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t");
        
        // Security: Check for dangerous patterns
        if sanitized.contains("<script>") || sanitized.contains("javascript:") {
            return Err(anyhow::anyhow!("Text contains dangerous patterns"));
        }
        
        Ok(sanitized)
    }

    fn sanitize_for_android(&self, text: &str) -> Result<String> {
        // Security: Sanitize text for Android/Kotlin
        let sanitized = text
            .replace("$", "\\$")
            .replace("\&quot;, "\\\&quot;)
            .replace("&quot;", "\\&quot;");
        
        // Security: Check for dangerous patterns
        if sanitized.contains("<script>") || sanitized.contains("javascript:") {
            return Err(anyhow::anyhow!("Text contains dangerous patterns"));
        }
        
        Ok(sanitized)
    }

    fn sanitize_for_ios(&self, text: &str) -> Result<String> {
        // Security: Sanitize text for iOS/Swift
        let sanitized = text
            .replace("\&quot;, "\\\&quot;)
            .replace("&quot;", "\\&quot;");
        
        // Security: Check for dangerous patterns
        if sanitized.contains("<script>") || sanitized.contains("javascript:") {
            return Err(anyhow::anyhow!("Text contains dangerous patterns"));
        }
        
        Ok(sanitized)
    }

    fn validate_wasm(&self, wasm_code: &str) -> Result<()> {
        // Security: Validate generated WASM
        if !wasm_code.contains("(module") {
            return Err(anyhow::anyhow!("Invalid WASM module"));
        }
        
        // Security: Check for dangerous patterns
        if wasm_code.contains("eval") || wasm_code.contains("exec") {
            return Err(anyhow::anyhow!("Generated WASM contains dangerous patterns"));
        }
        
        // Security: Validate size
        if wasm_code.len() > 1_000_000 {
            return Err(anyhow::anyhow!("Generated WASM too large"));
        }
        
        Ok(())
    }
}

// Public generate function
pub fn generate_code(app: &App, options: GeneratorOptions) -> Result<String> {
    let generator = CodeGenerator::new(options);
    generator.generate(app)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_wasm() {
        let app = App {
            name: "Test".to_string(),
            start_screen: "Home".to_string(),
            screens: vec![],
            state: vec![],
        };
        
        let options = GeneratorOptions::default();
        let result = generate_code(&app, options);
        assert!(result.is_ok());
    }

    #[test]
    fn test_sanitize_text() {
        let generator = CodeGenerator::new(GeneratorOptions::default());
        
        // Test dangerous text
        let result = generator.sanitize_for_wasm("<script>alert('xss')</script>");
        assert!(result.is_err());
        
        // Test safe text
        let result = generator.sanitize_for_wasm("Hello World");
        assert!(result.is_ok());
    }
}